## 4. MVC 프레임워크 만들기

### 4-1. 프론트 컨트롤러 패턴 소개

* 프론트 컨트롤러 도입 전
  ![](https://i.ibb.co/MDZJhR6/bandicam-2021-06-07-18-05-28-379.jpg)

* 프론트 컨트롤러 도입 후
  ![](https://i.ibb.co/61qfV5v/bandicam-2021-06-07-18-05-37-093.jpg)

* FrontController 패턴 특징
    * 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음
    * 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출
    * 입구를 하나로!!!
    * 공통 처리 가능
    * 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨

* 스프링 웹 MVC와 프론트 컨트롤러
    * 스프링 웹 MVC의 핵심이 바로 **FrontController**
    * 스프링 웹 MVC의 **DispatcherServlet**이 FrontController 패턴으로 구현되어 있음

### 4-2. 프론트 컨트롤러 도입 - v1

프론트 컨트롤러를 단계적으로 도입해보자.  
이번 목표는 기존 코드를 최대한 유지하면서, 프론트 컨트롤러를 도입하는 것이다. 먼저 구조를 맞추어두고 점진적으로 리펙터링 해보자.

#### v1 구조

![](https://i.ibb.co/rx1fW0z/bandicam-2021-06-07-19-17-07-773.jpg)

#### ControllerV1

```java
package hello.servlet.web.frontcontroller.v1;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public interface ControllerV1 {

    void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;
}

```

서블릿과 비슷한 모양의 컨트롤러 인터페이스를 도입한다. 각 컨트롤러들은 이 인터페이스를 구현하면 된다. 프론트 컨트롤러는 이 인터페이스를 호출해서 구현과 관계없이 로직의 일관석을 가져갈 수 있다.

이제 이 인테페이스를 구현한 컨트롤러를 만들어보자. 지금 단계에서는 기존 로직을 최대한 유지하는게 핵심이다.

#### MemberFormControllerV1

* 회원 등록 컨트롤러

```java
package hello.servlet.web.frontcontroller.v1.controller;

import hello.servlet.web.frontcontroller.v1.ControllerV1;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class MemberFormControllerV1 implements ControllerV1 {

    @Override
    public void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String viewPath = "/WEB-INF/views/new-form.jsp";
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }
}

```

* `HttpServlet`를 상속받는 것이 아닌 인터페이스 `ControllerV1`을 구현하였다.
    * 이후 다형성을 이용하여 매핑을 하기 위함
    * 단 `@WebServlet`를 사용하지 않으며, URI를 통한 매핑이 되지 않는다.
* 서블릿 부분(Controller)과 완전히 동일한 코드라고 해도 무방하다.
    * 각각의 컨트롤러들은 동일하게 만든다.(현재 단계에서는...)

#### MemberSaveControllerV1

* 회원 저장 컨트롤러

```java
package hello.servlet.web.frontcontroller.v1.controller;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import hello.servlet.web.frontcontroller.v1.ControllerV1;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class MemberSaveControllerV1 implements ControllerV1 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);

        request.setAttribute("member", member);

        String viewPath = "/WEB-INF/views/save-result.jsp";
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }
}

```

#### MemberListControllerV1

* 회원 목록 컨트롤러

```java
package hello.servlet.web.frontcontroller.v1.controller;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import hello.servlet.web.frontcontroller.v1.ControllerV1;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

public class MemberListControllerV1 implements ControllerV1 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        List<Member> members = memberRepository.findAll();

        request.setAttribute("members", members);

        String viewPath = "/WEB-INF/views/members.jsp";
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }
}

```

* 전체적으로 내부 로직은 기존 서블릿과 거의 같다.

#### FrontControllerServletV1

* 프론트 컨트롤러

```java
package hello.servlet.web.frontcontroller.v1;

import hello.servlet.web.frontcontroller.v1.controller.MemberFormControllerV1;
import hello.servlet.web.frontcontroller.v1.controller.MemberListControllerV1;
import hello.servlet.web.frontcontroller.v1.controller.MemberSaveControllerV1;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@WebServlet(name = "frontControllerServletV1", urlPatterns = "/front-controller/v1/*")
public class FrontControllerServletV1 extends HttpServlet {

    private Map<String, ControllerV1> controllerMap = new HashMap<>();

    public FrontControllerServletV1() {
        controllerMap.put("/front-controller/v1/members/new-form", new MemberFormControllerV1());
        controllerMap.put("/front-controller/v1/members/save", new MemberSaveControllerV1());
        controllerMap.put("/front-controller/v1/members", new MemberListControllerV1());
    }

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("FrontControllerServletV1.service");

        String requestURI = request.getRequestURI();

        ControllerV1 controller = controllerMap.get(requestURI);
        if (controller == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        controller.process(request, response);
    }
}

```

* `urlPatterns`
    * `urlPatterns = "/front-controller/v1/*"`: `/front-controller/v1`를 포함한 하위 모든 요청은 이 서블릿에서 받아들인다.
    * 예) `/front-controller/v1`, `/front-controller/v1/a`, `/front-controller/v1/a/b`

* `controllerMap`
    * key: 매핑 URL
    * value: 호출될 컨트롤러

* `servie()`
    * 먼저 `requestURI`를 조회해서 실제 호출할 컨트롤러를 `controllerMap`에서 찾는다.
        * 만약 없으면 404(`SC_NOT_FOUND`)상태 코드를 반환
    * 컨트롤러를 찾고 `controller.process(request, response);`을 호출해서 해당 컨트롤러를 실행한다.

* JSP
    * JSP는 이전 MVC에서 사용했던 것을 그대로 사용한다.

* 이전의 sevletMVC는 각 컨트롤러에 url패턴을 지정하였다면, 이번에는 모든 url 패턴이 `FrontControllerServletV1`으로 우선 간 후에 그 안에서 url를 분석하여 해당 컨트롤러로 다시
  뿌려진다.
    * 아직까지는 더 좋다는 느낌은 없다.
* 단 인터페이스의 구현체로 컨트롤러를 구현하고, 각 구현체들을 Map에 저장하였다. 이후에 Map에서 꺼낼때는 `ControllerV1 controller = controllerMap.get(requestURI)`
  형식으로 받았다.
    * 인터페이스와 구현체를 분리시고, map에서 받은 구현체들은 다시 인터페이스 형식으로 받았기에 어떠한 구현체가 호출되어도 단 한줄로 모두 받아낼 수 있다.(위대한 부모...) 이러한 방식으로 코딩하는 것은
      눈여겨 볼 필요가 있으며 실무에서도 많이 쓰이는 방식이라고 한다. (**다형성!!!!**)

### 4-3. View 분리 - v2

모든 컨트롤러에서 뷰로 이동하는 부분에 중복이 있고, 깔끔하지 않다.

```
String viewPath = "/WEB-INF/wiews/new-form.jsp"
RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
dispatcher.forward(request, response);
```

이 부분을 깔끔하게 분리하기 위해 별도로 뷰를 처리하는 객체를 만들자.

#### V2 구조

![](https://i.ibb.co/6tsstqd/bandicam-2021-06-07-21-38-20-244.jpg)

#### MyView

뷰 객체는 이후 다른 버전에서도 함께 사용하므로 패키지 위치를 `frontController`에 두었다.

```java
package hello.servlet.web.frontcontroller;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class MyView {

    private String viewPath;

    public MyView(String viewPath) {
        this.viewPath = viewPath;
    }

    public void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }
}

```

* 생성자에서 `viewPath`를 파라미터로 받는다.

```
String viewPath = "/WEB-INF/wiews/new-form.jsp"
```  

* 이후 `render`에서 랜더링 작업을 수행한다.

```
RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
dispatcher.forward(request, response);
```

* 중복되는 코드를 각각 생성자와 `render`메소드로 나누어서 작성했다고 이해하면 된다.

#### ControllerV2

```java
package hello.servlet.web.frontcontroller.v2;

import hello.servlet.web.frontcontroller.MyView;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public interface ControllerV2 {

    MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;
}

```

* 이전의 `ControllerV1`의 `process()`는 `void`를 반환한 것과는 다르게 `ControllerV2`의 `process()`는 `MyView`를 반환하고 있다.
    * 그 이유는 `ControllerV2`의 구현체와 `FrontControllerV2`에서 확인할 수 있다.

#### MemberFormControllerV2

* 회원 등록 폼

```java
package hello.servlet.web.frontcontroller.v2.controller;

import hello.servlet.web.frontcontroller.MyView;
import hello.servlet.web.frontcontroller.v2.ControllerV2;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class MemberFormControllerV2 implements ControllerV2 {

    @Override
    public MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        return new MyView("/WEB-INF/views/new-form.jsp");
    }
}

```

* 각 컨트롤러는 복잡한 `dispatcher.forward()`를 직접 생성해서 호출하지 않아도 된다.
    * 단순히 `MyView`객체를 생성하고 거기에 뷰 이름만 넣고 반환하면 된다.

* `ControllerV1`를 구현한 클래스와 `ControllerV2`를 구현한 클래스를 비교해보면, 이 부분의 중복이 확실하게 제거된 것을 확인할 수 있다.

#### MemberSaveControllerV2

* 회원 저장

```java
package hello.servlet.web.frontcontroller.v2.controller;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import hello.servlet.web.frontcontroller.MyView;
import hello.servlet.web.frontcontroller.v2.ControllerV2;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class MemberSaveControllerV2 implements ControllerV2 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);

        request.setAttribute("member", member);
        return new MyView("/WEB-INF/views/save-result.jsp");
    }
}

```

#### MemberListControllerV2

* 회원 목록

```java
package hello.servlet.web.frontcontroller.v2.controller;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import hello.servlet.web.frontcontroller.MyView;
import hello.servlet.web.frontcontroller.v2.ControllerV2;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

public class MemberListControllerV2 implements ControllerV2 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        List<Member> members = memberRepository.findAll();
        request.setAttribute("members", members);
        return new MyView("/WEB-INF/views/members.jsp");
    }
}

```

#### FrontControllerV2

```java
package hello.servlet.web.frontcontroller.v2;

import hello.servlet.web.frontcontroller.MyView;
import hello.servlet.web.frontcontroller.v2.controller.MemberFormControllerV2;
import hello.servlet.web.frontcontroller.v2.controller.MemberListControllerV2;
import hello.servlet.web.frontcontroller.v2.controller.MemberSaveControllerV2;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@WebServlet(name = "frontControllerServletV2", urlPatterns = "/front-controller/v2/*")
public class FrontControllerServletV2 extends HttpServlet {

    private Map<String, ControllerV2> controllerMap = new HashMap<>();

    public FrontControllerServletV2() {
        controllerMap.put("/front-controller/v2/members/new-form", new MemberFormControllerV2());
        controllerMap.put("/front-controller/v2/members/save", new MemberSaveControllerV2());
        controllerMap.put("/front-controller/v2/members", new MemberListControllerV2());
    }

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String requestURI = request.getRequestURI();

        ControllerV2 controller = controllerMap.get(requestURI);
        if (controller == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        MyView view = controller.process(request, response);
        view.render(request, response);
    }
}
```

* ControllerV2의 반환 타입이 `Myview`이므로 프론트 컨트롤러는 컨트롤러의 호출 결과로 `MyView`를 반환 받는다. 그리고 `view.render()`를 호출하면 `forward()`로직을
  수행해서 JSP가 실행된다.

* 프론트 컨트롤러의 도입으로 `MyView`객체의 `render()`를 호출하는 부분을 모두 일관되게 처리할 수 있다. 각각의 컨트롤러는 `MyView`객체를 생성만 해서 반환하면 된다.

* 현 단계에서는 중복되는 코드를 메소드로 abstract하여 간결화 하였다.
    * 간결화 한 방법이 객체를 반환해서 객체의 메소드를 실행 하도록 한 방법은 참고할 만 하다.

### 4-4. Model 추가 - v3

#### 서블릿 종속성 제거

* 컨트롤러 입장에서 `HttpServletRequest`, `HttpServletResponse`이 꼭 필요할까?
* 요청 파라미터 정보는 자바의 `Map`으로 대신 넘기도록 하면 지금 구조에서는 컨트롤러가 서블릿 기술을 몰라도 동작할 수 있다.
* `request`객체를 `Model`로 사용하는 대신에 별도의 `Model`객체를 만들어서 반환하면 된다.
* 우리가 구현하는 컨트롤러가 서블릿 기술을 전혀 사용하지 않도록 변경해보자.
    * 구현 코드도 매우 단순해지고, 테스트 코드 작성이 쉽다.

#### 뷰 이름 중복 제거

* 컨트롤러에서 지정하는 뷰 이름에 중복이 있는 것을 확인 할 수 있다.
* 컨트롤러는 **뷰의 논리 이름**을 반환하고, 실제 물리 위치의 이름은 프론트 컨트롤러에서 처리하도록 단순화 하자.
* 이렇게 해두면 향후 뷰의 폴더 위치가 함께 이동해도 프론트 컨트롤러만 고치면 된다.
    * `/WEB-INF/views/new-form.jsp` -> **new-form**
    * `/WEB-INF/views/save-result.jst` -> **sve-result**
    * `/WEB-INF/views/members.jsp` -> **members**

#### V3 구조

![](https://i.ibb.co/zXFQW3r/bandicam-2021-09-19-16-27-38-278.jpg)

#### ModelView

지금까지 컨트롤러에서 서블릿에 종속적인 `HttpServletRequest`를 사용했다. 그리고 `Model`도 `request.setAttribute()`를 통해 데이터를 저장하고 뷰에 전달했다.  
서블릿의 종속성을 제거하기 위해 Model을 직접 만들고, 추가로 View 이름까지 전달하는 객체를 만들어 보자.     
(이번 버전에서는 컨트롤러에서 `HttpServletRequest`를 사용할 수 없다. 따라서 직접 `request.setAttribute()`를 호출할 수 도 없다. 따라서 Model이 별도로 필요하다.)

참고로 `ModelView`객체는 다른 버전에서도 사용하므로 패키지를 `frontcontroller`에 둔다.

* `src/main/java/hello/servlet/web/frontcontroller/ModelView.java`

```java
package hello.servlet.web.frontcontroller;

import java.util.HashMap;
import java.util.Map;

public class ModelView {

    private String viewName;
    private Map<String, Object> model = new HashMap<>();

    public ModelView(String viewName) {
        this.viewName = viewName;
    }

    public String getViewName() {
        return viewName;
    }

    public void setViewName(String viewName) {
        this.viewName = viewName;
    }

    public Map<String, Object> getModel() {
        return model;
    }

    public void setModel(Map<String, Object> model) {
        this.model = model;
    }
}

```

뷰의 이름과 뷰를 랜더링할 때 필요한 model 객체를 가지고 있다. model은 단순히 map으로 되어 있으므로 컨트롤러에서 뷰에 필요한 데이터를 key, value로 넣어주면 된다.

* `Map<String, Object> model = new HashMap<>()`
    * 만약 save를 예로 들어 보자.
    * `request`에서 `getParameter()`를 이용해서 `username`, `age`를 뽑아서 `Member`객체를 만든 후에 그 객체를 `MemberRepository`에
      저장하고, `Member`객체를 `save-result.jsp`로 넘겨서 출력을 하기 위해서 model에 넘겨주는 행위로 `request.setAttribute("member", member)`를 했다.
    * `setAttribute()`메소드의 파라미터가 객체의 이름과 실제 객체를 파라미터로 받는것에서 Map을 이용하면 Model을 구현할 수 있다는 것을 알 수 있다.

#### ControllerV3

* Controller 인터페이스
* `src/main/java/hello/servlet/web/frontcontroller/v3/ControllerV3.java`

```java
package hello.servlet.web.frontcontroller.v3;

import hello.servlet.web.frontcontroller.ModelView;

import java.util.Map;

public interface ControllerV3 {

    ModelView process(Map<String, String> paramMap);
}

```

* 이 컨트롤러는 서블릿 기술을 전혀 사용하지 않는다.
    * 따라서 구현이 매우 단순해지고, 테스트 코드 작성시 테스트 하기 쉽다.

* `HttpServletRequest`가 제공하는 파라미터는 프론트 컨트롤러가 `paramMap`에 담아서 호출해주면 된다.
* 응답 결과로 뷰 이름과 뷰에 전달할 Model 데이터를 포함하는 `ModelView`객체를 반환하면 된다.
    * 이후 `FrontController`에서 반환받는 `ModelView`에서 뷰의 이름과 모델을 바탕으로 JSP 문서롤 호출함과 동시에 JSP에서는 필요한 데이터를 model에서 꺼내서 쓸수 있다.

#### MemberFromControllerV3

* 회원 등록 폼
* `src/main/java/hello/servlet/web/frontcontroller/v3/controller/MemberFormControllerV3.java`

```java
package hello.servlet.web.frontcontroller.v3.controller;

import hello.servlet.web.frontcontroller.ModelView;
import hello.servlet.web.frontcontroller.v3.ControllerV3;

import java.util.Map;

public class MemberFormControllerV3 implements ControllerV3 {

    @Override
    public ModelView process(Map<String, String> paramMap) {
        return new ModelView("new-form");
    }
}

```

* `ModelView`를 생성할 때 `new-form`이라는 view의 **논리적인 이름**을 지정한다.
    * 실제 물리적인 이름은 프론트 컨트롤러에서 처리한다.
    * 물리적인 이름: `/WEB-INF/views/new-form.jsp`
    * 모든 jsp를 같은 패키지인 `/WEB-INF/views`에 저장하니 이 부분을 중복으로 작성하는 것을 피하고자 하는 방법이다.
    * 논리적인 이름이 jsp의 파일 이름이라고 생각하면 쉽다.

#### MemberSaveControllerV3

* 회원 저장
* `src/main/java/hello/servlet/web/frontcontroller/v3/controller/MemberSaveControllerV3.java`

```java
package hello.servlet.web.frontcontroller.v3.controller;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import hello.servlet.web.frontcontroller.ModelView;
import hello.servlet.web.frontcontroller.v3.ControllerV3;

import java.util.Map;

public class MemberSaveControllerV3 implements ControllerV3 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public ModelView process(Map<String, String> paramMap) {
        String username = paramMap.get("username");
        int age = Integer.parseInt(paramMap.get("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);

        ModelView mv = new ModelView("save-result");
        mv.getModel().put("member", member);
        return mv;
    }
}

```

* `paramMap.get("username")`
    * 파라미터 정보는 `map`에 담겨있다. map에서 필요한 요청 파라미터를 조회하면 된다.
    * `v2`에서는 `request`에서 직접 `getParameter()`를 사용해서 파라미터 정보를 뽑아내었다. 이 부분에서 서블릿에 종속적이므로 이를 없애고자 `HttpServletRequest`객체
      대신에 객체의 정보를 `paramMap`에 전달 한 후에 이를 파라미터도 전달 받았다.
    * 역할로 보자면 `paramMap` = `HttpServletRequest`라고 생각해도 무방하다.

* `mv.getModel().put("member", member)`
    * 모델은 단순한 map이므로 모델에 뷰에서 필요한 `member`객체를 담고 반환한다.
    * `request.setAttribute("member", member)`와 동일한 과정이다.
    * 이전에 `request`를 Model로 사용했다면 이번에는 Model를 따로 구현했기 때문에 그 Model(`mv.getModel()`)에 JSP가 필요로 하는 데이터를 넘겨주는 것이다.

#### MemberListControllerV3

* 회원 목록
* `src/main/java/hello/servlet/web/frontcontroller/v3/controller/MemberListControllerV3.java`

```java
package hello.servlet.web.frontcontroller.v3.controller;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import hello.servlet.web.frontcontroller.ModelView;
import hello.servlet.web.frontcontroller.v3.ControllerV3;

import java.util.List;
import java.util.Map;

public class MemberListControllerV3 implements ControllerV3 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public ModelView process(Map<String, String> paramMap) {
        List<Member> members = memberRepository.findAll();
        ModelView mv = new ModelView("members");
        mv.getModel().put("members", members);
        return mv;
    }
}

```

#### FrontControllerServletV3

* `src/main/java/hello/servlet/web/frontcontroller/v3/FrontControllerServiceV3.java`

```java
package hello.servlet.web.frontcontroller.v3;

import hello.servlet.web.frontcontroller.ModelView;
import hello.servlet.web.frontcontroller.MyView;
import hello.servlet.web.frontcontroller.v3.controller.MemberFormControllerV3;
import hello.servlet.web.frontcontroller.v3.controller.MemberListControllerV3;
import hello.servlet.web.frontcontroller.v3.controller.MemberSaveControllerV3;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@WebServlet(name = "frontControllerServiceV3", urlPatterns = "/front-controller/v3/*")
public class FrontControllerServiceV3 extends HttpServlet {

    private Map<String, ControllerV3> controllerMap = new HashMap<>();

    public FrontControllerServiceV3() {
        controllerMap.put("/front-controller/v3/members/new-form", new MemberFormControllerV3());
        controllerMap.put("/front-controller/v3/members/save", new MemberSaveControllerV3());
        controllerMap.put("/front-controller/v3/members", new MemberListControllerV3());
    }

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String requestURI = request.getRequestURI();

        ControllerV3 controller = controllerMap.get(requestURI);
        if (controller == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        Map<String, String> paramMap = createParamMap(request);
        ModelView mv = controller.process(paramMap);

        String viewName = mv.getViewName();
        MyView view = viewResolver(viewName);

        view.render(mv.getModel(), request, response);
    }

    private MyView viewResolver(String viewName) {
        return new MyView("/WEB-INF/views/" + viewName + ".jsp");
    }

    private Map<String, String> createParamMap(HttpServletRequest request) {
        Map<String, String> paramMap = new HashMap<>();

        request.getParameterNames().asIterator()
                .forEachRemaining(paramName -> paramMap.put(paramName, request.getParameter(paramName)));
        return paramMap;
    }
}

```

* `view.render(mv.getModel(), request, response)`코드에 컴파일 오류가 발생할 것이다. (`MyView`클래스에서 메소드 추가가 필요하다.)

* `Map<String, String> paramMap = createParamMap(request)`
    * `HttpServletRequest`역할을 대신하는 `paramMap`을 생성한다.
    * `createParamMap()`
        * `HttpServletRequest`를 파라미터로 받아서 그 정보들을 모두 Map형태로 저장한 후에 그 Map을 반환한다. 즉 `HttpServletRequest` -> `Map`

* `ModelView mv = controller.process(paramMap)`
    * `paramMap`을 전달하여 각 컨트롤러를 실행시킨다.
    * 각 컨트롤러의 실행 결과는 `ModelView`객체로 반환되며 이 객체는 View를 위한 데이터가 저장되어 있다.
    * 복습겸 언급하자면 `ModelView`객체에는 `view`의 논리적 이름(jsp 파일 이름)과 jsp 파일이 필요로 하는 데이터가 저장되어 있는 model로 구성되어 있다.

* `viewResolver(viewName)`
    * 논리적인 이름으로 저장되어 있는 `viewName`을 물리적 경로를 추가한 물리적 이름, 즉 경로를 포함하고 있는 형태로 변환하는 것이다.
        * 논리 뷰 이름: `member`
        * 물리 뷰 경로: `/WEB-INF/views/members.jsp`
    * 모든 jsp파일은 `/WEB-INF/views`에 저장되어 있고, 모든 파일이 jsp이므로 확장자는 `.jsp`이다.
    * `MyView`객체에 파라미터로 물리적인 뷰 이름을 전달하여 생성한다.

#### MyView

* `render(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response)` 메소드 추가
* `src/main/java/hello/servlet/web/frontcontroller/MyView.java`

```java
package hello.servlet.web.frontcontroller;

import javax.servlet.RequestDispatcher;
import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

public class MyView {

    private String viewPath;

    public MyView(String viewPath) {
        this.viewPath = viewPath;
    }

    public void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }

    // --------------------- 추가 시작 -------------------------------
    public void render(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        modelToRequestAttribute(model, request);
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }

    private void modelToRequestAttribute(Map<String, Object> model, HttpServletRequest request) {
        model.forEach(request::setAttribute);
    }

    // --------------------- 추가 끝---------------------------------
}

```

* 뷰 객체를 통해서 HTML 화면을 렌더링 한다.
* 뷰 객체의 `render()`는 모델 정보도 함께 받는다.
* JSP는 `request.getAttribute()`로 데이터를 조회하기 때문에, 모델의 데이터를 꺼내서 `request.setAttrubute()`로 담아둔다.
* JSP로 forward 해서 JSP를 렌더링 한다.

> `MyView`에서 알수 있듯이, `ModelView`를 만들어서 `HttpServletRequest`객체가 Model의 역할을 수행했던 부분을 대신했지만, 모든 역할을 수행하진 못한다.
>   * HTML 화면을 랜더링 하는 과정에서는 결국 필요한 데이터를 `HttpServletRequest`객체에서 뽑아서 사용한다.
>   * 지금 버전은 Controller의 입장에서 서블릿에 종속하지 않도록 구현하기 위한 Model를 만든 것이다.
>   * 가짜 모델(`ModelView`)은 다시 모든 정보를 `request.setAttrubute()`를 통해 `request`에 넘겨주어야 한다.
>
> 처음에는 `ModelView`의 `model`이 Model의 모든 역할을 수행할 수 있다고 이해해서 코드 이해가 되지 않았다. 주의하자. 마지막엔 다시 모든 정보를 `request.setAttrubue()`로 전달한다.

### 4-5. 단순하고 실용적인 컨트롤러 - v4

앞서 만든 v3 컨트롤러는 서블릿 종속성을 제거하고 뷰 경로의 중복을 제거하는 등, 잘 설계된 컨트롤러이다. 그런데 실제 컨트롤러 인터페이스를 구현하는 개발자 입장에서 보면, 항상 `ModelView`객체를 생성하고
반환해야 하는 부분이 조금은 번거롭다.      
좋은 프레임워크는 아키텍처도 중요하지만, 그와 더불어 실제 개발하는 개발자가 단순하고 편리하게 사용할 수 있어야 한다. 소위 실용성이 있어야 한다.

이번에는 v3를 조금 변경해서 실제 구혀하는 개발자들이 매우 편리하게 개발할 수 있는 v4 버전을 개발해 보자.

#### v4 구조

![](https://i.ibb.co/DWYgYxb/bandicam-2021-06-09-18-02-24-217.jpg)

* 기본적인 구조는 v3와 같다. 대신에 컨트롤러가 `ModelView`를 반환하지 않고, `ViewName`만 반환한다.

#### ControllerV4

* `src/main/java/hello/servlet/web/frontcontroller/v4/ControllerV4.java`

```java
package hello.servlet.web.frontcontroller.v4;

import java.util.Map;

public interface ControllerV4 {

    /**
     * @param paramMap
     * @param model
     * @return viewName
     */
    String process(Map<String, String> paramMap, Map<String, Object> model);
}

```

* 파라미터로 기존의 `paramMap`이외에 `model`를 추가로 받는다.
    * `ModelView` 필드의 `model`이 이번에는 파라미터로 전달된다.

* 이번버전은 이터페이스에 `ModelView`가 없다. model 객체는 파라미터로 전달되기 때문에 그냥 사용하면 되고, 결과로 뷰의 이름만 반환해주면 된다.

#### MemberFormControllerV4

* `src/main/java/hello/servlet/web/frontcontroller/v4/controller/MemberFormControllerV4.java`

```java
package hello.servlet.web.frontcontroller.v4.controller;

import hello.servlet.web.frontcontroller.v4.ControllerV4;

import java.util.Map;

public class MemberFormControllerV4 implements ControllerV4 {

    @Override
    public String process(Map<String, String> paramMap, Map<String, Object> model) {
        return "new-form";
    }
}

```

#### MemeberSaveControllerV4

* `src/main/java/hello/servlet/web/frontcontroller/v4/controller/MemberSaveControllerV4.java`

```java
package hello.servlet.web.frontcontroller.v4.controller;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import hello.servlet.web.frontcontroller.v4.ControllerV4;

import java.util.Map;

public class MemberSaveControllerV4 implements ControllerV4 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public String process(Map<String, String> paramMap, Map<String, Object> model) {
        String username = paramMap.get("username");
        int age = Integer.parseInt(paramMap.get("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);
        model.put("member", member);
        return "save-result";
    }
}

```

* `model.put("member", member)`
    * 모델이 파라미터로 전달되기 때문에, 모델을 직접 생성하지 않아도 된다.

#### MemberListControllerV4

* `src/main/java/hello/servlet/web/frontcontroller/v4/controller/MemberListControllerV4.java`

```java
package hello.servlet.web.frontcontroller.v4.controller;

import hello.servlet.domain.member.Member;
import hello.servlet.domain.member.MemberRepository;
import hello.servlet.web.frontcontroller.v4.ControllerV4;

import java.util.List;
import java.util.Map;

public class MemberListControllerV4 implements ControllerV4 {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public String process(Map<String, String> paramMap, Map<String, Object> model) {
        List<Member> members = memberRepository.findAll();

        model.put("members", members);
        return "members";
    }
}

```

#### FrontControllerServletV4

* `src/main/java/hello/servlet/web/frontcontroller/v4/FrontControllerServiceV4.java`

```java
package hello.servlet.web.frontcontroller.v4;

import hello.servlet.web.frontcontroller.MyView;
import hello.servlet.web.frontcontroller.v4.controller.MemberFormControllerV4;
import hello.servlet.web.frontcontroller.v4.controller.MemberListControllerV4;
import hello.servlet.web.frontcontroller.v4.controller.MemberSaveControllerV4;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@WebServlet(name = "frontControllerServiceV4", urlPatterns = "/front-controller/v4/*")
public class FrontControllerServletV4 extends HttpServlet {

    private Map<String, ControllerV4> controllerMap = new HashMap<>();

    public FrontControllerServletV4() {
        controllerMap.put("/front-controller/v4/members/new-form", new MemberFormControllerV4());
        controllerMap.put("/front-controller/v4/members/save", new MemberSaveControllerV4());
        controllerMap.put("/front-controller/v4/members", new MemberListControllerV4());
    }

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String requestURI = request.getRequestURI();

        ControllerV4 controller = controllerMap.get(requestURI);
        if (controller == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        Map<String, String> paramMap = createParamMap(request);
        Map<String, Object> model = new HashMap<>();

        String viewName = controller.process(paramMap, model);

        MyView view = viewResolver(viewName);
        view.render(model, request, response);
    }

    private MyView viewResolver(String viewName) {
        return new MyView("/WEB-INF/views/" + viewName + ".jsp");
    }

    private Map<String, String> createParamMap(HttpServletRequest request) {
        Map<String, String> paramMap = new HashMap<>();

        request.getParameterNames().asIterator()
                .forEachRemaining(paramName -> paramMap.put(paramName, request.getParameter(paramName)));
        return paramMap;
    }
}

```

* 이전버전(`FrontControllerServletV3`)과 거의 동일하다.

* 모델 객체 전달
    * Map<Stgring, Object> model = new HashMap<>();`
    * 모델 객체를 프론트 컨트롤러에서 생성해서 넘겨준다. 컨트롤러에서 모델 객체에 값을 담으면 여기에 그대로 담겨있게 된다.

* 뷰의 논리 이름을 직접 반환
    * 컨트롤러가 직접 뷰의 논리 이름을 반환하므로 이 값을 사용해서 실제 물리 뷰를 찾을 수 있다.

```
String viewName = controller.process(paramMap, model);
MyView view = viewREsolver(viewName);
```

> v3 를 확실하게 이해하고 넘어왔다면 이번 단계는 매우 쉽게 느껴질 것이다.    
> 그만큼 v3가 중요하므로 완벽하게 이해하고 넘어가자.

### 4-6. 유연한 컨트롤러1 - v5

만약 어떤 개발자는 `ControllerV3`방식으로 개발하고 싶고, 어떤 개발자는 `ControllerV4`방식으로 개발하고 싶다면 어떻게 해야 할까?

```
public interface ControllerV3 {
    ModelView process(Map<String, String> paramMap);
}
```

```
public interface ControllerV4 {
    String process(Map<String, String> paramMap, Map<String, Object> model);
}
```

#### 어댑터 패턴

지금까지 우리가 개발한 프론트 컨트롤러는 한가지 방식의 컨트롤러 인터페이스만 사용할 수 있다.        
`ControllerV3`, `ControllerV4`는 완전히 다른 인터페이스이다. 따라서 호환이 불가능하다. 마치 v3는 110v이고, v4는 220v 전기 콘센트 같은 것이다. 이럴 때 사용하는 것이 바로
어댑터이다.    
어댑터 패턴을 사용해서 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있다록 변경해보자.

#### V5 구조

![](https://i.ibb.co/DMYMc3h/bandicam-2021-06-09-22-39-29-706.jpg)

* **핸들러 어댑터**: 중간에 어댑터 역할을 하는 어댑터가 추가되었는데 이름이 핸들러 어댑터이다. 여기서 어댑터 역할을 해주는 덕분에 다양한 종류의 컨트롤러를 호출할 수 있다.
* **핸들러**: 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경했다. 그 이유는 이제 어댑터가 있기 때문에 꼭 컨트롤러의 개념 뿐만 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 다 처리할 수 있기
  때문이다.

#### MyHandlerAdapter

* 어댑터용 인터페이스
* `src/main/java/hello/servlet/web/frontcontroller/v5/MyHandlerAdapter.java`

```java
package hello.servlet.web.frontcontroller.v5;

import hello.servlet.web.frontcontroller.ModelView;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public interface MyHandlerAdapter {

    boolean supports(Object handler);

    ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException;
}

```

* `boolean supports(Object handler)`
    * **handler는 컨트롤러를 말한다!!!**
    * 어댑터가 해당 컨트롤러를 처리할 수 있는지 판단하는 메서드다.
* `ModelView handle(HttpServletRequest request, HttpServletResponse respone, Object handler)`
    * 어댑터는 실제 컨트롤러를 호출하고, 그 결과로 `ModelView`를 반환해야 한다.
    * 실제 컨트롤러가 `ModelView`를 반환하지 못하면, 어댑터가 `ModelView`를 직접 생성해서라도 반환해야 한다.
    * 이전에는 프론트 컨트롤러가 실제 컨트롤러를 호출했지만 이제는 이 어댑터를 통해서 실제 컨트롤러가 호출된다.

#### ControllerV3HandlerAdapter

* `ControllerV3`을 지원하는 어댑터
* `src/main/java/hello/servlet/web/frontcontroller/v5/adapter/ControllerV3HandlerAdapter.java`

```java
package hello.servlet.web.frontcontroller.v5.adapter;

import hello.servlet.web.frontcontroller.ModelView;
import hello.servlet.web.frontcontroller.v3.ControllerV3;
import hello.servlet.web.frontcontroller.v5.MyHandlerAdapter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class ControllerV3HandlerAdapter implements MyHandlerAdapter {

    @Override
    public boolean supports(Object handler) {
        return (handler instanceof ControllerV3);
    }

    @Override
    public ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException {
        ControllerV3 controller = (ControllerV3) handler;

        Map<String, String> paramMap = createParamMap(request);
        return controller.process(paramMap);
    }

    private Map<String, String> createParamMap(HttpServletRequest request) {
        Map<String, String> paramMap = new HashMap<>();
        request.getParameterNames().asIterator()
                .forEachRemaining(paramName -> paramMap.put(paramName, request.getParameter(paramName)));
        return paramMap;
    }
}

```

* `handler instance of ControllerV3`
    * `객체 + instanceof + 클래스`
    * 형변환이 가능한 지 해당 여부를 `true` `false`로 반환
    * 부모객체인지 자식 객체인지 확인하는데 쓰임
    * `getClass()`: 현재 참조하고 있는 클래스를 확인

```
ControllerV3 controller = (ControllerV3) handler;
Map<String, String> paramMap = new HashMap<>();
ModelView mv = controller.process(paramMap);
return mv;
```

* handler를 컨트롤러 V3으로 변환한 다음에 V3 형식에 맞도록 호출한다.
* `support()`를 통해 `ControllerV3`만 지원하기 때문에 타입 변환은 걱정없이 실행해도 된다.
* `ControllerV3`는 `ModelView`를 반환하므로 그대로 `ModelView`를 반환하면 된다.

#### FrontControllerServletV5

* `src/main/java/hello/servlet/web/frontcontroller/v5/FrontControllerServletV5.java`

```java
package hello.servlet.web.frontcontroller.v5;

import hello.servlet.web.frontcontroller.ModelView;
import hello.servlet.web.frontcontroller.MyView;
import hello.servlet.web.frontcontroller.v3.controller.MemberFormControllerV3;
import hello.servlet.web.frontcontroller.v3.controller.MemberListControllerV3;
import hello.servlet.web.frontcontroller.v3.controller.MemberSaveControllerV3;
import hello.servlet.web.frontcontroller.v5.adapter.ControllerV3HandlerAdapter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@WebServlet(name = "frontControllerServletV5", urlPatterns = "/front-controller/v5/*")
public class FrontControllerServletV5 extends HttpServlet {

    private final Map<String, Object> handlerMappingMap = new HashMap<>();
    private final List<MyHandlerAdapter> handlerAdapters = new ArrayList<>();

    public FrontControllerServletV5() {
        initHandlerMappingMap();
        initHandlerAdapters();
    }

    private void initHandlerMappingMap() {
        handlerMappingMap.put("/front-controller/v5/v3/members/new-form", new MemberFormControllerV3());
        handlerMappingMap.put("/front-controller/v5/v3/members/save", new MemberSaveControllerV3());
        handlerMappingMap.put("/front-controller/v5/v3/members", new MemberListControllerV3());
    }

    private void initHandlerAdapters() {
        handlerAdapters.add(new ControllerV3HandlerAdapter());
    }

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Object handler = getHandler(request);
        if (handler == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        MyHandlerAdapter adapter = getHandlerAdapter(handler);

        ModelView mv = adapter.handle(request, response, handler);

        String viewName = mv.getViewName();
        MyView view = viewResolver(viewName);

        view.render(mv.getModel(), request, response);
    }

    private Object getHandler(HttpServletRequest request) {
        String requestURI = request.getRequestURI();
        return handlerMappingMap.get(requestURI);
    }

    private MyHandlerAdapter getHandlerAdapter(Object handler) {
        for (MyHandlerAdapter adapter : handlerAdapters) {
            if (adapter.supports(handler)) {
                return adapter;
            }
        }
        throw new IllegalArgumentException("handler adapter를 찾을 수 없습니다. handler = " + handler);
    }

    private MyView viewResolver(String viewName) {
        return new MyView("/WEB-INF/views/" + viewName + ".jsp");
    }

    private Map<String, String> createParamMap(HttpServletRequest request) {
        Map<String, String> paramMap = new HashMap<>();

        request.getParameterNames().asIterator()
                .forEachRemaining(paramName -> paramMap.put(paramName, request.getParameter(paramName)));
        return paramMap;
    }
}

```

* **컨트롤러(Controller) -> 핸들러(Handler)**
    * 이전에는 컨트롤러를 직접 매핑해서 사용했다. 그런데 이제는 어댑터를 사용하기 때문에, 컨트롤러 뿐만 아니라 어댑터가 지원하기만 하면, 어떤 것이라도 URL에 매핑해서 사용할 수 있다. 그래서 이름을
      컨트롤러에서 더 넓은 범위의 핸들러로 변경했다.

* 생성자
    ```java
    public class FrontControllerServletV5() {
        initHandlerMappingMap(); // 핸들러 매핑 초기화
    
        initHandlerAdapters(); // 어댑터 초기화
    }
    ```
    * 생성자는 핸들러 매핑과 어댑터를 초기화(등록)한다.
    * 핸들러가 곧 컨트롤임을 생각해보면 컨트롤를 매핑하는 행위와 동일하다.

* 매핑 정보
  `private final Map<String, Object> handlerMappingMap = new HashMap<>();`
    * 매핑 정보의 값이 `ControllerV3`, `ControllerV4`같은 인터페이스에서 아무 값이나 받을 수 있는 `Object`로 변경되었다.

* 핸들러 매핑
  `Object handler = getHandler(request)`
  ```
  private Object getHandler(HttpServletRequest request) {
        String requestURI = request.getRequestURI();
        return handlerMappingMap.get(requestURI);
  ```
    * 핸들러 매핑 정보인 `handlerMappingMap`에서 URL에 매핑된 핸들러(컨트롤러)객체를 찾아서 반환한다.

* 핸들러를 처리할 수 있는 어댑터 조회
  `MyHandlerAdapter adapter = getHandlerAdapter(handler)`
    * `handler`를 처리할 수 있는 어댑터를 `adapter.supports(handler)`를 통해서 찾는다.
    * `handler`가 `ControllerV3`인터페이스를 구현했다면, `ControllerV3HandlerAdapter`객체가 반환된다.

* 어댑터 호출
  `ModelView mv = adapter.handle(request, response, handler);`
    * 어댑터의 `handle(request, response, handler)`를 통해서 실제 어댑터가 호출된다.
    * 어댑터는 `handler`(컨트롤러)를 호출하고 그 결과를 어댑터에 맞추어 반환한다.
    * `ControllerV3HandlerAdapter`의 경우 어댑터의 모양과 컨트롤러의 모양이 유사해서 변환 로직이 단순하다.

> MTH   
> 코드를 처음 작성하면 한번에 이해하기가 어려울 수 있다. 단순하게 생각하면 된다.     
> 이전에는 컨트롤러를 `FrontController`에서 호출했다면 이번에는 `FrontController`에서 어댑터를 호출한다. 어댑터는 `Object`형인 `handler`를 알맞은 형(`ControllerV3`)으로 변환을 하고 `handle()`메소드를 통해 `process` 메소드를 실행시켜서 `ModelView`형으로 반환한다.
>
> 변환(어댑터) -> 처리(핸들러 = 컨트롤러)

### 4-7. 유연한 컨트롤러2 - v5

#### FrontControllerServletV5 - ControllerV4 기능 추가

* 코드 추가
* `src/main/java/hello/servlet/web/frontcontroller/v5/FrontControllerServletV5.java`

```java
package hello.servlet.web.frontcontroller.v5;

@WebServlet(name = "frontControllerServletV5", urlPatterns = "/front-controller/v5/*")
public class FrontControllerServletV5 extends HttpServlet {

    private final Map<String, Object> handlerMappingMap = new HashMap<>();
    private final List<MyHandlerAdapter> handlerAdapters = new ArrayList<>();

    public FrontControllerServletV5() {
        initHandlerMappingMap();
        initHandlerAdapters();
    }

    private void initHandlerMappingMap() {
        handlerMappingMap.put("/front-controller/v5/v3/members/new-form", new MemberFormControllerV3());
        handlerMappingMap.put("/front-controller/v5/v3/members/save", new MemberSaveControllerV3());
        handlerMappingMap.put("/front-controller/v5/v3/members", new MemberListControllerV3());

        // ----------------------- 추가 시작 ----------------------------
        handlerMappingMap.put("/front-controller/v5/v4/members/new-form", new MemberFormControllerV4());
        handlerMappingMap.put("/front-controller/v5/v4/members/save", new MemberSaveControllerV4());
        handlerMappingMap.put("/front-controller/v5/v4/members", new MemberListControllerV4());
        // ----------------------- 추가 끝 ----------------------------
    }

    private void initHandlerAdapters() {
        handlerAdapters.add(new ControllerV3HandlerAdapter());
        handlerAdapters.add(new ControllerV4HandlerAdapter()); // 추가---
    }
}
```

* 핸들러 매핑(`handlerMappingMap`)에 `ControllerV4`를 사용하는 컨트롤러를 추가
* 해당 컨트롤러를 처리할 수 있는 어댑터인 `ControllerV4HandlerAdapter` 추가
    * 아직 `ControllerV4HandlerAdapter`를 구현하지 않았으므로 에러 발생

#### ControllerV4HandlerAdapter

* `src/main/java/hello/servlet/web/frontcontroller/v5/adapter/ControllerV4HandlerAdapter.java`

```java
package hello.servlet.web.frontcontroller.v5.adapter;

import hello.servlet.web.frontcontroller.ModelView;
import hello.servlet.web.frontcontroller.v4.ControllerV4;
import hello.servlet.web.frontcontroller.v5.MyHandlerAdapter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class ControllerV4HandlerAdapter implements MyHandlerAdapter {

    @Override
    public boolean supports(Object handler) {
        return handler instanceof ControllerV4;
    }

    @Override
    public ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException {
        ControllerV4 controller = (ControllerV4) handler;

        Map<String, String> paramMap = createParamMap(request);
        Map<String, Object> model = new HashMap<>();

        String viewName = controller.process(paramMap, model);

        ModelView mv = new ModelView(viewName);
        mv.setModel(model);

        return mv;
    }

    private Map<String, String> createParamMap(HttpServletRequest request) {
        Map<String, String> paramMap = new HashMap<>();
        request.getParameterNames().asIterator()
                .forEachRemaining(paramName -> paramMap.put(paramName, request.getParameter(paramName)));
        return paramMap;
    }
}

```

* `ControllerV4`에서는 `process()`메소드가 파라미터로 `paramMap`과 `model`를 받아서 `viewName`을 `String`형으로 반환했다.
    * 기존에 `ModelView`의 필드를 이루는 `viewName`과 `model`를 가지고 새로운 `ModelView`객체를 생성해서 반환했다.

* 변환하는 과정은 `ControllerV3HandlerAdapter`와 동일하다.

> MTH       
> `handle()`메소드는 `ModelView`를 반환한다. `ControllerV3HandlerAdapter`를 구현할때는 `ControllerV3`의 `process`가 `ModelView`를 반환했기 때문에 반환값을 그대로 `handle()`의 반환값으로 썼다.     
> 하지만 `ControllerV4`에서는 `process()`외부에서 `model`를 만들고 파라미터로 전달한 후에 반환값은 `viewName`을 가졌다. 처음에는 당황할 수 있으나, 결국에는 `handle`의 반환값인 `ModelView`를 이루는 요소인 `viewName`과 `model`모두 가지고 있기에 새로 객체를 생성해서 반환하면 된다.     
> `mv.setModel(model)`

### 4-8. 정리

지금까지 v1 ~ v5로 점진적으로 프레임워크를 발전시켜 왔다.

* v1: 프론트 컨트롤러를 도입
    * 기존 구조를 최대한 유지하면서 프론트 컨트롤러를 도입

* v2: View 분류
    * 단순 반복 되는 뷰 로직 분리

* v3: Model 추가
    * 서블릿 종속성 제거
    * 뷰 이름 중복 제거

* v4: 단순하고 실용적인 컨트롤러
    * v3과 거의 비슷
    * 구현 입장에서 ModelView를 직접 생성해서 반환하지 않도록 편리한 인터페이스 제공

* v5: 유연한 컨트롤러
    * 어댑터 도입
    * 어댑터를 추가해서 프레임워크를 유연하고 확장성 있게 설계

여기에 애노테이션을 사용해서 컨트롤러를 더 편리하게 발전시킬 수도 있다. 만약 애노테이션을 사용해서 컨트롤러를 편리하게 사용할 수 있게 하려면 어떻게 해야 할까? 바로 애노테이션을 지원하는 어댑터를 추가하면
된다.!        
다형성과 어댑터 덕분에 기존 구조를 유지하면서, 프레임워크의 기능을 확장할 수 있다.